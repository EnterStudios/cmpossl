=pod

=head1 NAME

 CMP_CTX_create,
 CMP_CTX_init,
 CMP_CTX_delete,
 CMP_CTX_set1_referenceValue,
 CMP_CTX_set1_secretValue,
 CMP_CTX_set1_regToken,
 CMP_CTX_set1_caCert,
 CMP_CTX_set1_srvCert,
 CMP_CTX_set1_clCert,
 CMP_CTX_set1_oldClCert,
 CMP_CTX_set1_subjectName,
 CMP_CTX_set1_issuer,
 CMP_CTX_set1_newClCert,
 CMP_CTX_set0_pkey,
 CMP_CTX_set0_newPkey,
 CMP_CTX_set1_pkey,
 CMP_CTX_set1_newPkey,
 CMP_CTX_set1_transactionID,
 CMP_CTX_set1_recipNonce,
 CMP_CTX_set_option,
 CMP_CTX_caPubs_get1,
 CMP_CTX_caPubs_pop,
 CMP_CTX_caPubs_num,
 CMP_CTX_set1_caPubs,
 CMP_CTX_policyOID_push1,
 CMP_CTX_set1_extraCertsOut,
 CMP_CTX_extraCertsOut_push1,
 CMP_CTX_extraCertsOut_num,
 CMP_CTX_extraCertsIn_get1,
 CMP_CTX_set1_extraCertsIn,
 CMP_CTX_extraCertsIn_pop,
 CMP_CTX_extraCertsIn_num,
 CMP_CTX_set0_trustedStore,
 CMP_CTX_set0_untrustedStore,
 CMP_CTX_get0_trustedStore,
 CMP_CTX_set0_crls,
 CMP_CTX_set_certVerify_callback,
 CMP_CTX_set_error_callback,
 CMP_CTX_set_debug_callback,
 CMP_printf,

 CMP_CTX_statusString_get
 CMP_CTX_failInfoCode_get
 CMP_CTX_set_failInfoCode
 CMP_CTX_set_popoMethod
 CMP_CTX_set1_proxyName
 CMP_CTX_set_proxyPort
 CMP_CTX_set0_tlsBIO
 CMP_CTX_get_tlsBIO
 CMP_CTX_set1_recipient
 CMP_CTX_set1_serverName
 CMP_CTX_set1_serverPath
 CMP_CTX_set_serverPort
 CMP_CTX_set0_reqExtensions
 CMP_CTX_set_msg_transfer
 CMP_CTX_set_certConf_callback
 CMP_CTX_subjectAltName_push1

=head1 SYNOPSIS

 #include <openssl/cmp.h>

 CMP_CTX *CMP_CTX_create();
 int CMP_CTX_init( CMP_CTX *ctx);
 void CMP_CTX_delete(CMP_CTX *ctx);

 int CMP_CTX_set1_referenceValue( CMP_CTX *ctx, const unsigned char *ref, size_t len);
 int CMP_CTX_set1_secretValue( CMP_CTX *ctx, const unsigned char *sec, const size_t len);
 int CMP_CTX_set1_regToken(CMP_CTX *ctx, const char *regtoken, const size_t len);
 int CMP_CTX_set1_caCert( CMP_CTX *ctx, const X509 *cert);
 int CMP_CTX_set1_srvCert(CMP_CTX *ctx, const X509 *cert);
 int CMP_CTX_set1_clCert( CMP_CTX *ctx, const X509 *cert);
 int CMP_CTX_set1_oldClCert( CMP_CTX *ctx, const X509 *cert);
 int CMP_CTX_set1_subjectName( CMP_CTX *ctx, const X509_NAME *name);
 int CMP_CTX_set1_issuer( CMP_CTX *ctx, const X509_NAME *name);
 int CMP_CTX_set1_newClCert( CMP_CTX *ctx, const X509 *cert);
 int CMP_CTX_set0_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
 int CMP_CTX_set0_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
 int CMP_CTX_set1_pkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
 int CMP_CTX_set1_newPkey( CMP_CTX *ctx, const EVP_PKEY *pkey);
 int CMP_CTX_set1_transactionID( CMP_CTX *ctx, const ASN1_OCTET_STRING *id);
 int CMP_CTX_set1_recipNonce( CMP_CTX *ctx, const ASN1_OCTET_STRING *nonce);
 int CMP_CTX_set1_serverName( CMP_CTX *ctx, const char *name);
 int CMP_CTX_set_serverPort( CMP_CTX *ctx, int port);
 STACK_OF(X509) *CMP_CTX_caPubs_get1(CMP_CTX *ctx);
 X509 *CMP_CTX_caPubs_pop( CMP_CTX *ctx);
 int CMP_CTX_caPubs_num( CMP_CTX *ctx);
 int CMP_CTX_set1_caPubs( CMP_CTX *ctx, const STACK_OF(X509) *caPubs);
 int CMP_CTX_policyOID_push1( CMP_CTX *ctx, const char *policyOID);
 int CMP_CTX_geninfo_itav_push0(CMP_CTX *ctx, CMP_INFOTYPEANDVALUE *itav);
 int CMP_CTX_genm_itav_push0(CMP_CTX *ctx, CMP_INFOTYPEANDVALUE *itav);

 int CMP_CTX_set1_extraCertsOut( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsOut);
 int CMP_CTX_extraCertsOut_push1( CMP_CTX *ctx, const X509 *val);
 int CMP_CTX_extraCertsOut_num( CMP_CTX *ctx);
 STACK_OF(X509) *CMP_CTX_extraCertsIn_get1(CMP_CTX *ctx);
 int CMP_CTX_set1_extraCertsIn( CMP_CTX *ctx, const STACK_OF(X509) *extraCertsIn);
 X509 *CMP_CTX_extraCertsIn_pop( CMP_CTX *ctx);
 int CMP_CTX_extraCertsIn_num( CMP_CTX *ctx);

 int CMP_CTX_set0_trustedStore( CMP_CTX *ctx, X509_STORE *store);
 int CMP_CTX_set0_untrustedStore( CMP_CTX *ctx, X509_STORE *store);
 int CMP_CTX_set0_crls(CMP_CTX *ctx, STACK_OF(X509_CRL) *crls);
 int CMP_CTX_set_certVerify_callback(CMP_CTX *ctx, cert_verify_cb_t cb);

 X509_STORE *CMP_CTX_get0_trustedStore(CMP_CTX *ctx);

 int CMP_CTX_set_error_callback( CMP_CTX *ctx, cmp_logfn_t cb);
 int CMP_CTX_set_debug_callback( CMP_CTX *ctx, cmp_logfn_t cb);
 void CMP_printf(const CMP_CTX *ctx, const char *fmt, ...);

 int CMP_CTX_set_option( CMP_CTX *ctx, const int opt, const int val);

 STACK_OF(ASN1_UTF8STRING) *CMP_CTX_statusString_get(CMP_CTX *ctx);
 unsigned long CMP_CTX_failInfoCode_get(CMP_CTX *ctx);
 int CMP_CTX_set_failInfoCode( CMP_CTX *ctx, CMP_PKIFAILUREINFO *failInfo);
 int CMP_CTX_set_popoMethod( CMP_CTX *ctx, int method);
 int CMP_CTX_set1_proxyName( CMP_CTX *ctx, const char *name);
 int CMP_CTX_set_proxyPort( CMP_CTX *ctx, int port);
 int CMP_CTX_set0_tlsBIO(CMP_CTX *ctx, BIO *sbio);
 BIO *CMP_CTX_get_tlsBIO(CMP_CTX *ctx);
 int CMP_CTX_set1_recipient( CMP_CTX *ctx, const X509_NAME *name);
 int CMP_CTX_set1_serverPath( CMP_CTX *ctx, const char *path);
 int CMP_CTX_set0_reqExtensions(CMP_CTX *ctx, X509_EXTENSIONS *exts);
 int CMP_CTX_set_msg_transfer(CMP_CTX *ctx, cmp_transfer_fn_t cb);
 int CMP_CTX_set_certConf_callback( CMP_CTX *ctx, cmp_certConfFn_t cb);
 int CMP_CTX_subjectAltName_push1( CMP_CTX *ctx, const GENERAL_NAME *name);

=head1 DESCRIPTION

This is the context API for using CMP (Certificate Management Protocol) with OpenSSL.

CMP_CTX_create() allocates and initialized an CMP_CTX structure.

CMP_CTX_init() initializes the context to default values. Transfer is set to
HTTP, proof-of-possession method to POPOSigningKey

CMP_CTX_delete() frees any allocated non-ASN1 fields of CMP_CTX and
calls the ASN1 defined CMP_CTX_free() function to free the rest.

CMP_CTX_set1_referenceValue() sets the given referenceValue in the given
CMP_CTX structure.

CMP_CTX_set1_secretValue() sets the B<secret> with the length B<len> in the B<ctx>.

CMP_CTX_set1_regToken() set the registration token value.

CMP_CTX_set1_caCert() sets the given CA Certificate in the given CMP_CTX
structure.

CMP_CTX_set1_srvCert() sets the server certificate to be used for verifying response messages.
Also also sets ctx->trusted_store to contain (only) this certificate.
The certificate argument may be NULL to clear the entry.

CMP_CTX_set1_clCert() sets the given Client Certificate in the given
CMP_CTX structure. The Client Certificate will then be used by the
functions to set the "sender" field for messages originating from the
client. The private key belonging to this certificate is then used
create the protection in case of MSG_SIG_ALG.

CMP_CTX_set1_oldClCert() sets the old certificate that we are updating
in KUR. If this is not set, clCert will be the one being updated.
This is also used to specify the certificate to be revoked in RR.

CMP_CTX_set1_subjectName() sets the subject name that will be used in
the CertTemplate structure when requesting a new certificate. Note that
if clCert is set, the name will be read from them and this will be
ignored.

CMP_CTX_set1_issuer() sets the name of the intended issuer that 
will be set in the PKIHeader, i.e., the X509 name of the CA server.

CMP_CTX_set1_newClCert() sets the given (newly obtained) Client
Certificate in the given CMP_CTX structure.

CMP_CTX_set0_pkey() sets the given EVP_PKEY structure, holding the
private and public keys, belonging to the Client Certificate, in the
given CMP_CTX structure.

CMP_CTX_set1_pkey() is the same as above, except that it does not
consume the pointer.

CMP_CTX_set0_newPkey() sets the given EVP_PKEY structure, holding the
private and public keys, which shall be certified, in the given CMP_CTX
structure

CMP_CTX_set1_newPkey() is the same as above, except that it does not
consume the pointer.

CMP_CTX_set1_transactionID() sets the given transaction ID in the given
CMP_CTX structure.

CMP_CTX_set1_recipNonce() sets the given recipient nonce in the given
CMP_CTX structure.

CMP_CTX_set1_serverName() sets the given server Address (as IP or name)
in the given CMP_CTX structure.

CMP_CTX_set_serverPort() sets the port of the CMP server to connect to.

CMP_CTX_set_option() sets the given value for the given option
(e.g. CMP_CTX_OPT_IMPLICITCONFIRM) in the given CMP_CTX structure.

The following options can be set:
    CMP_CTX_OPT_IMPLICITCONFIRM
        Request server to enable implicit confirm mode, where the client
        does not need to send confirmation upon receiving the
        certificate. If the server does not enable implicit confirmation
        in the return message, then confirmation is sent anyway.

    CMP_CTX_OPT_DISABLECONFIRM
        Do not confirm enrolled certificates, to cope with broken servers
        not supporting implicit confirmation correctly.
B<WARNING:> This setting leads to unspecified behaviour and it is meant
exclusively to allow interoperability with server implementations violating
RFC 4210.

    CMP_CTX_OPT_UNPROTECTED_REQUESTS
        Send messages without CMP-level protection.

    CMP_CTX_OPT_UNPROTECTED_ERRORS
        Accept unprotected error responses: regular error messages as well as
        certificate responses (IP/CP/KUP) and revocation responses (RP) with rejection.
B<WARNING:> This setting leads to unspecified behaviour and it is meant
exclusively to allow interoperability with server implementations violating
RFC 4210.

    CMP_CTX_OPT_POPOMETHOD
        Select the proof of possession method to use. Possible values are:
            CRMF_POPO_NONE      - ProofOfPossession field omitted
            CRMF_POPO_SIGNATURE - sign a value with private key
            CRMF_POPO_ENCRCERT - decrypt the encrypted certificate
                                 ("indirect method")
            CRMF_POPO_RAVERIFIED - assert that the RA has already
                                   verified the PoPo

    CMP_CTX_OPT_DIGEST_ALGNID
        The digest algorithm NID to be used in RFC 4210's MSG_SIG_ALG,
        if applicable used for message protection and Proof-of-Posession.

    CMP_CTX_OPT_MSGTIMEOUT
        Number of seconds (or 0 for infinite) a CMP message round trip is
        allowed to take before a timeout error is returned. Default is 120.

    CMP_CTX_OPT_MAXPOLLTIME
        Maximum total number of seconds to attempt polling for
        certificates on 'waiting' PKIStatus. Default is 0 (infinite).

    CMP_CTX_PERMIT_TA_IN_EXTRACERTS_FOR_IR
        Allow retrieving a trust anchor from extraCers and using that
        to validate the certificate chain of an IP message.

    CMP_CTX_OPT_SUBJECTALTNAME_CRITICAL
        Flag demanding that the SubjectAltName extension is critical

    CMP_CTX_OPT_REVOCATION_REASON
        The reason code to be included in revocation request (RR);
        values: 0..10 (RFC 5210, 5.3.1) or -1 for none (which is the default)

CMP_CTX_caPubs_num() can be used after an Initial Request or Key Update
request to check the number of CA certificates that were sent from the
server.

CMP_CTX_caPubs_get1() returns a duplicate of the stack of X509 certificates 
that were received in the caPubs field of the last response message.

CMP_CTX_caPubs_pop() pops one CA certificates of the stack of received
CA certs and returns it

CMP_CTX_set1_caPubs() copies the given caPubs stack to the context so
that it may be accessed later by CMP_CTX_caPubs_num() and
CMP_CTX_caPubs_pop().

CMP_CTX_policyOID_push1() adds the certificate policy OID given by the
string to the X509_EXTENSIONS of the certificate template we are
requesting.

CMP_CTX_geninfo_itav_push0() adds B<itav> to the stack in the B<ctx> to be added
to the GeneralInfo field of the CMP PKIMessage header of a request message sent
with this context.  Consumes the pointer to B<itav>.

CMP_CTX_genm_itav_push0() adds B<itav> to the stack in the B<ctx> which will be
the body of a General Message sent with this context.  Consumes the pointer to
B<itav>.

CMP_CTX_set1_extraCertsOut() sets the stack of extraCerts that will be
sent to remote.

CMP_CTX_extraCertsOut_push1() adds the given certificate to the outbound
extraCerts stack, without consuming the pointer.

CMP_CTX_extraCertsOut_num() returns the number of certificates in the
outbound extraCerts stack.

CMP_CTX_extraCertsIn_get1() returns a copy of the stack of certificates 
received in a response message.

CMP_CTX_set1_extraCertsIn() sets the stack of extraCerts that was
received from remote.

CMP_CTX_extraCertsIn_pop() pops and returns one certificate off the
stack of extra certificates received from remote.

CMP_CTX_extraCertsIn_num() returns the number of certificates that were
received from remote.

CMP_CTX_set0_trustedStore() sets the X509_STORE type certificate store
containing trusted root CA certificates, used for CMP server authentication.
Cannot be used together with srvCert, which is explicitly/directly trusted.

CMP_CTX_set0_untrustedStore() sets the X509_STORE type certificate store
containing intermediate certificates used for path construction 
in CMP server authentication.

CMP_CTX_get0_trustedStore(CMP_CTX *ctx) returns a pointer to the trusted
store.

CMP_CTX_set0_crls() sets CRLs to be used as primary source during CMP
server certificate verification.

CMP_CTX_set_certVerify_callback() sets callback function to be used during
certificate verification for diagnosis, and optionally modifying the result.
See also B<SSL_CTX_set_verify>.

CMP_CTX_set_error_callback() sets a callback function for receiving
error messages.

CMP_CTX_set_debug_callback() sets a callback function for receiving
debug messages.

CMP_printf() is used for printing debug messages if debug_cb is set
(CMP_CTX_INIT defaults to puts()).

CMP_CTX_statusString_get() returns the statusString from the last 
CertRepMessage, NULL on error.

CMP_CTX_set_failInfoCode() sets the failinfo error code bits in CMP_CTX 
based on the given CMP_PKIFAILUREINFO structure.

CMP_CTX_failInfoCode_get() returns the CMP error code from the failInfo
field. This is a bit field and the flags for it are specified in
cmp.h. The flags start with CMP_CTX_FAILINFO, for example:
CMP_CTX_FAILINFO_badAlg.

CMP_CTX_set1_proxyName() sets the hostname of the HTTP proxy to be used
for connecting to the CA server.

CMP_CTX_set_proxyPort() sets the port of the HTTP proxy.

CMP_CTX_set0_tlsBIO() sets the SSL/TLS BIO to be used for HTTPS.
The argument value may be NULL for none, which is the default.

CMP_CTX_get0_tlsBIO() returns the SSL/TLS BIO used for HTTPS, or NULL.

CMP_CTX_set1_recipient() sets the recipient name that will be used in the
PKIHeader, i.e. the X509 name of the CA server, unless srvCert is set.
Defaults to given issuer; for RR, further defaults to issuer of certificate to be revoked.

CMP_CTX_set1_serverPath() sets the HTTP path of the CMP server on the host.

CMP_CTX_set0_reqExtensions() sets the X.509v3 extensions to be used in IR/CR/KUR

CMP_CTX_set_msg_transfer() sets the messagetransfer callback function used for
sending CMP requests and receiving responses. Default is CMP_PKIMESSAGE_http_perform().
The function given as argument must have type
int (*cmp_transfer_fn_t) (const CMP_CTX *ctx, const CMP_PKIMESSAGE *req, CMP_PKIMESSAGE **res);
This function should send the PKIMessage req and on success place the response in *res.
On success it must return 0, else a CMP error reason code defined in cmp.h.

CMP_CTX_set_certConf_callback() sets a callback that can be used to
check the certificate received from the server. If the certificate
shall be accepted the callback should return -1 (indicating success),
else a bit number <= CMP_PKIFAILUREINFO_MAX indicating failure.

CMP_CTX_subjectAltName_push1() adds the given X509 name to the list of
alternate names on the certificate template request.  If this is done,
and the subject name is not set with CMP_CTX_set1_subjectName(), then in
IR and CR, the certificate template will not be filled with the subject
name from the existig client certificate.  If a subject name is desired
it needs to be set explicitly with CMP_CTX_set1_subjectName().

=head1 NOTES

CMP is defined in RFC 4210 (and CRMF in RFC 4211).

The implementation of CMP for OpenSSL is still work in progress. The API
might change every release!

=head1 RETURN VALUES

CMP_CTX_create() returns a pointer to an initialized CMP_CTX structure.

All other functions return 0 on error, 1 on success.

=head1 EXAMPLE

The following code does an Initial Request:

        cmp_ctx = CMP_CTX_create();
        CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
        CMP_CTX_set1_referenceValue( cmp_ctx, idString, idStringLen);
        CMP_CTX_set1_secretValue( cmp_ctx, secret, secretLen);
        CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
        CMP_CTX_set1_caCert( cmp_ctx, caCert);

        initialClCert = CMP_doInitialRequestSeq(cmp_ctx);

The following code does an Initial Request with, using an
external identity certificate (RFC 4210, Appendix E.7):

        cmp_ctx = CMP_CTX_create();
        CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
        CMP_CTX_set1_referenceValue( cmp_ctx, idString, idStringLen);
        CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
        CMP_CTX_set1_caCert( cmp_ctx, caCert);

        initialClCert = CMP_doInitialRequestSeq(cmp_ctx);

Here externalCert is an X509 certificate granted to the EE by another CA
which is trusted by the current CA the code will connect to.


The following code does a Key Update Request:

        cmp_ctx = CMP_CTX_create();
        CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
        CMP_CTX_set0_pkey( cmp_ctx, initialPkey);
        CMP_CTX_set0_newPkey( cmp_ctx, updatedPkey);
        CMP_CTX_set1_clCert( cmp_ctx, initialClCert);
        CMP_CTX_set1_caCert( cmp_ctx, caCert);

        updatedClCert = CMP_doKeyUpdateRequestSeq(cmp_ctx);

The following code (which omits error handling) sends a genm including, as an 
example, the id-it-signKeyPairTypes OID and prints info on the genp contents.

    cmp_ctx = CMP_CTX_create();
    CMP_CTX_set1_serverName( cmp_ctx, opt_serverName);
    CMP_CTX_set1_referenceValue( cmp_ctx, idString, idStringLen);
    CMP_CTX_set1_secretValue( cmp_ctx, password, passwordLen);

    ASN1_OBJECT *type = OBJ_txt2obj("1.3.6.1.5.5.7.4.2", 1);
    CMP_INFOTYPEANDVALUE *itav = CMP_ITAV_new(type, NULL);
    CMP_CTX_genm_itav_push0(cmp_ctx, itav);

    STACK_OF(CMP_INFOTYPEANDVALUE) *itavs;
    itavs = CMP_doGeneralMessageSeq(cmp_ctx);
    print_itavs(itavs);
    sk_CMP_INFOTYPEANDVALUE_pop_free(itavs, CMP_INFOTYPEANDVALUE_free);

=head1 TODO

Create functions to tune the PBM parameters pbm_* which are pre-set.

=head1 SEE ALSO

CMP_ses, CMP_http
